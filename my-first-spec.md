# DP3T Backend Specification

The backend consists of two main functions: providing a set <blabla short explaination in simple english or for simple english people>.



## Operational setting

Logical/abstract architecture - to help discuss the non-functional, information security and compliance aspects of any implementation. And help guide what needs to be arranged in terms of gouvernance.

## Overview

There are three systems/backends in play. 

* A CDN like bulk publishing system (b, c) that pushes out the infection lists to all mobiles participating, every day.
* A system that collects the data from just the (infected) mobiles, just once per infection
* [optionally] An approval/filtering process that ensures that only validated infections make it into the official list for those countries that require, say, a test or a professional assesment.

![Overview](overview.png)


A Mobile app(a) installed on million of devices does regular (e.g. 1-4 times per day) fetches through a common Content Delivery Network (CDN), with no particular integrity or reliability guarantees (best effort)[^1].

Fetched is a (possibly digitally signed file (c)) with the contamination details of the day. This file is generated by a very reliable central backend (m) and contains just the relevant information (p).

At some point (e.g. on a national scale, several 10's to 100's of time an hour) a medical professional will ask if his patient is willing to divulge his contact (process f,mg,h,i) or something or someone deceides that an infection needs to be reported.


The device then posts, j, plain http(s)/REST, its opaque contact data to the receiver(k). Depending on the protocol - this is either a seed or the actually broadcasted IDs (d).
 
This is filtered, at pure IP level, by (k); where no data is kept but a short log and a few percent of the net-flows.

The list of the last 14 days is then filtered, if appropriate, before it is deliveryed every few hours or every day to the distribution area.

## Ramfications for the API

This means there are three areas with very different properties. 

* CDN: bulk, only handles public data, best effort, needs to be hit by the whole population. very few privacy concerns beyond the usual ones of seeing IP's and headers. Should respond fast/efficient. No state, no need for logging or backups.
* Receiver: little traffic, but should `never loose' data and much more privacy sensitive - as there is an implied; this person may be infected. Batch oriented; so no speed or other concerns; very clear data retention expectations
* Is Infected Approval process (optional): process that supports medical processes - and may be highly sensitive - but largely based on existing processes, medical records, Laboratory Information Systems and so on; and inteface is just an 'ok' to publish.

This allows for API optimisation.


## Overview for app developers

To check for infection: first load the list of data dumps from /exposed.

#### Design 1 DP3T and TCN:

	for each (dump-you-havent-processed-or-which-has-a-new-hash)
		take the seed; reconstruct the N broadcasted ID
			for each id reconstructed
				check them in the list of local ids received.
					stop if you are in it.

##### Design 2:

	for each (dump-you-havent-processed-or-which-has-a-new-hash)
		load data from `uri_filter` into your cocofilter
			check each of your local ids for precence in the cocofilter.
					stop if you are in it.


Optionally - if Design 2 is to carry metadata (like TCN and PACT) or if the filter is very small/'too' efficent

	for each (dump-you-havent-processed-or-which-has-a-new-hash)
		load data from `uri_filter` into your cocofilter
			check each of your local ids for precence in the cocofilter.
			if ( interaction in cocofilter )
				download a partial list of ids from uri_data	
					stop if you are in it.

#### PACT and TCN:

	for each (dump-you-havent-processed-or-which-has-a-new-hash)
		check them in the list of local ids received.
			stop if you are in it.

# Endpoints -- CDN / bulk distribition

Below end points are all for the CDN / bulk distribution.

Non functional expectations are

* Handle at least one fetch/day from the mobiles (millions of request per day, thousands per second).
* Very resistant to repeated/superfluent fetches
* Bad behaviour of one should not jeapordie _delivery_ to others.
* Little or no security
* Tamperproofing is desirable - but for most protocols not uber critical as the match-space is very large and thus resistant against false positives. The tampering is a risk for not reporting infected people that they are infected (which is in fact what some device owners may well desire, e.g. to keep their jobs).

#### general option/concern

Sign all responses with a RFC 3161 timestamp/signature

## /exposed 

	GET /{version}/exposed

Response:

	application/json

	{
		[{
			time_stamp_from: 'isodatetime',
			time_stamp_to: 'iso',
			hash: 'hash_which_identifies_this_for_changes'
			uri_filter: '/whatever/the/uri/is/for/the/coocoofilter'
			uri_data: '/whatever/the/uri/is/for/the/big/binary'
			exposed_key_bits: 8 /* ZZZZ number of bits to use for 'exposed/<key>/extra-data fetches
		}, ...]

	}

Response description:

	Returns an json array containing a list of data batches in reverse-chronological order - so the latest update comes first. The timespan of the file is included along with a relative url to the coco filter binary and to the data file binary. The hash identifies the uri_data and thus changes if the data changes (so mistakes can be fixed).

Q: Why do we need the hash ? It is too late by the time you see it ? And you can do a hash on the payload, eTag/get-if-modified more important ?

Q: How about a 

	GET /{version}/exposed/<n>
	
With <n> being 0 for the first fetch; and if the time_stamp_to is too low; you fetch 1, then 2, then 3 until the app decides it has enough ? So we can optimise this if we have waves of infections ? And can optimise purely backend ?

## /exposed/filter

	GET /{version}/exposed/{batch-id}/filter

Response:

	application/octet-stream

	<example CocoFilterFormat>

Response description:

	Some text

Q: batchID - I think that want to use the N bits of the 'verify' key here from the Cuckoo filter ? Or alternatively in some config advertise how small that 'N' kan be (see field ZZZ above).

## /exposed/data

	GET /{version}/exposed/{batch-id}/extra-data

	application/octet-stream

	<example ExposedDeviceIdentifiersFormat>

Params

     Where 'batch-id' are the first N bits of the (hashed) key - with N from the cuckoo filter used.

## /meta/configuration

Returns configuration for the risk algorithm:

see: end of page 11 of the WP https://github.com/DP-3T/documents/blob/master/DP3T%20White%20Paper.pdf


## /meta/authorities

Returns a list containing the infection authority per region/country. Where this api can be found so you can check your risks if you've been abroad.

	GET /meta/authorities

	application/json

	{
		"NL": "",
		"DE": "",
		...
	}

*Ryan: ideally this would be a published at a single well known source globally and not included in an api.*

# Messages

## CoCoFilterFormat

Define it.

## ExposedDeviceIdentifiersFormat

Define it.



^1: It will likely be a requirement that the CDN webservers have the Date: header set (RFC 2616, section 14.18) correctly -- as this stabilises the calcuation of 't'.
